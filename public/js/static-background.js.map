{
  "version": 3,
  "sources": ["static-background.ts"],
  "sourcesContent": ["// Type definitions for the static background effect\n\n// Export to make this file a module (required for global augmentation)\nexport {};\n\ntype EffectState = 'normal' | 'intensifying' | 'intense' | 'fading';\n\ninterface StaticConfig {\n    pixelSize: number;\n    density: number;\n    baseAlpha: number;\n    alphaVariance: number;\n    darkIntensityMin: number;\n    darkIntensityMax: number;\n    lightIntensityMin: number;\n    lightIntensityMax: number;\n    frameInterval: number;\n    usePartialRedraw: boolean;\n    partialRedrawRatio: number;\n    maxStoredFrames: number;\n    staticDivisor: number;\n    effectState: EffectState;\n    intenseDensity: number;\n    intenseColor: [number, number, number];\n    transitionProgress: number;\n    transitionSpeed: number;\n    currentDensity: number;\n    currentColorMix: number;\n}\n\ninterface DotGroup {\n    coords: [number, number][];\n    alpha: number;\n}\n\ninterface FramePixelGroup {\n    alpha: number;\n    pixels: [number, number][];\n}\n\ninterface StaticFrame {\n    [intensity: string]: FramePixelGroup;\n}\n\ninterface DotsByIntensity {\n    [intensity: string]: DotGroup;\n}\n\ninterface EffectColors {\n    purple: [number, number][];\n    cyan: [number, number][];\n    white: [number, number][];\n}\n\ninterface PerformanceData {\n    frameTimes: number[];\n    maxFrameTimes: number;\n    slowFrameThreshold: number;\n    slowFrameCount: number;\n    adaptationThreshold: number;\n    addFrameTime(duration: number): void;\n    adaptSettings(): void;\n}\n\ninterface StaticBackgroundAPI {\n    enableMagicMode(): void;\n    disableMagicMode(): void;\n    setIntense(): void;\n    setNormal(): void;\n}\n\ndeclare global {\n    interface Window {\n        staticBackground?: StaticBackgroundAPI;\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', (): void => {\n    const canvas = document.getElementById('staticCanvas') as HTMLCanvasElement | null;\n    // Important: Check if the canvas element actually exists before proceeding\n    if (!canvas) {\n        return;\n    }\n    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D | null;\n\n    if (!ctx) {\n        return;\n    }\n\n    let animationFrameId: number;\n    // Use prefers-color-scheme to sync with your CSS :root variables\n    let isDarkMode: boolean = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    // --- Configurable Parameters ---\n    // Basic static effect configuration\n    const config: StaticConfig = {\n        pixelSize: 1.25,       // Keep 1px for authentic fine-grained static\n        density: 1,      // Increased from original 0.8 for more dense static\n        baseAlpha: 0.85,    // Base alpha for normal mode\n        alphaVariance: 0.25, // Alpha variance for normal mode\n\n        // Color ranges (0-255) - Enhanced contrast\n        darkIntensityMin: 30,  // Brighter dots on dark bg\n        darkIntensityMax: 100, // Wider range for better visibility\n        lightIntensityMin: 135, // Darker dots on light bg\n        lightIntensityMax: 200, // Wider range for better visibility\n\n        // Frame timing\n        frameInterval: 40, // Slightly increased from original for performance\n\n        // Use partial redraw to improve performance\n        usePartialRedraw: true,\n        partialRedrawRatio: 0.4, // Redraw 40% of the static per frame\n        maxStoredFrames: 5, // Store this many frames for cycling\n\n        // Static calculation divisor (lower = more dots)\n        staticDivisor: 42, // Reduced from 50 for higher density\n\n        // Effect state tracking\n        effectState: 'normal', // Can be 'normal', 'intensifying', 'intense', 'fading'\n\n        // Intense mode parameters (what we transition to)\n        intenseDensity: 1.3,    // Reduced from 1.5 for better performance\n        intenseColor: [200, 120, 255], // Purple magic color\n\n        // Transition parameters\n        transitionProgress: 0,   // Progress from 0-1\n        transitionSpeed: 0.012,  // How much to increment per frame\n\n        // Effect parameters that will be dynamically calculated\n        currentDensity: 0.66,   // Will be updated during transitions\n        currentColorMix: 0      // 0 = normal colors, 1 = intense colors\n    };\n    // -----------------------------\n\n    let lastFrameTime: number = 0;\n\n    // Store previous frames of static\n    let staticPixels: StaticFrame[] = [];\n\n    function resizeCanvas(): void {\n        canvas!.width = window.innerWidth;\n        canvas!.height = window.innerHeight;\n\n        // Reset static pixels cache when resizing\n        staticPixels = [];\n    }\n\n    function drawStatic(timestamp: number): void {\n        // --- Frame Rate Limiting ---\n        if (timestamp - lastFrameTime < config.frameInterval) {\n            animationFrameId = requestAnimationFrame(drawStatic);\n            return;\n        }\n        lastFrameTime = timestamp;\n        // --------------------------------------\n\n        ctx!.clearRect(0, 0, canvas!.width, canvas!.height);\n\n        // Update the effect state and transition progress\n        updateEffectState();\n\n        // Draw base static layer - either full redraw or partial\n        if (config.usePartialRedraw) {\n            drawPartialStatic();\n        } else {\n            drawFullStatic();\n        }\n\n        // Draw effect layer if needed\n        if (config.effectState !== 'normal' && config.transitionProgress > 0) {\n            drawEffectLayer();\n        }\n\n        // Request the next frame\n        animationFrameId = requestAnimationFrame(drawStatic);\n    }\n\n    // Function to draw full static pattern (original approach but optimized)\n    function drawFullStatic(): void {\n        // Calculate number of static dots based on screen size with slight reduction\n        const screenRatio: number = Math.min(1.0, (canvas!.width * canvas!.height) / (1920 * 1080));\n        const baseStaticDots: number = Math.floor((canvas!.width * canvas!.height) / config.staticDivisor * config.density * screenRatio);\n\n        // Batch draw by intensity for fewer state changes\n        const dotsByIntensity: DotsByIntensity = {};\n\n        // Generate random dots and group by intensity\n        for (let i = 0; i < baseStaticDots; i++) {\n            const x: number = Math.floor(Math.random() * canvas!.width);\n            const y: number = Math.floor(Math.random() * canvas!.height);\n\n            // Use integer intensity values for better batching\n            let intensity: number;\n            if (isDarkMode) {\n                intensity = Math.floor(config.darkIntensityMin + Math.random() * (config.darkIntensityMax - config.darkIntensityMin));\n            } else {\n                intensity = Math.floor(config.lightIntensityMin + Math.random() * (config.lightIntensityMax - config.lightIntensityMin));\n            }\n\n            const alpha: number = config.baseAlpha + (Math.random() - 0.5) * config.alphaVariance;\n\n            // Group by intensity for batch rendering\n            if (!dotsByIntensity[intensity]) {\n                dotsByIntensity[intensity] = {\n                    coords: [],\n                    alpha: alpha\n                };\n            }\n\n            dotsByIntensity[intensity].coords.push([x, y]);\n        }\n\n        // Draw each intensity group in a batch\n        for (const intensity in dotsByIntensity) {\n            const dots: DotGroup = dotsByIntensity[intensity];\n            ctx!.fillStyle = `rgba(${intensity}, ${intensity}, ${intensity}, ${dots.alpha})`;\n\n            for (const [x, y] of dots.coords) {\n                ctx!.fillRect(x, y, config.pixelSize, config.pixelSize);\n            }\n        }\n    }\n\n    // Function for partial redraw of static (more efficient)\n    function drawPartialStatic(): void {\n        // If we don't have enough stored frames, create a new one\n        if (staticPixels.length < config.maxStoredFrames) {\n            // Generate a new frame of static\n            const newFrame: StaticFrame = generateStaticFrame();\n            staticPixels.push(newFrame);\n\n            // Draw all stored frames\n            for (const frame of staticPixels) {\n                drawStaticFrame(frame);\n            }\n        } else {\n            // We have enough frames, so cycle them and update one\n            // Remove oldest frame\n            staticPixels.shift();\n\n            // Generate new frame with partial coverage\n            const partialFrame: StaticFrame = generatePartialStaticFrame();\n            staticPixels.push(partialFrame);\n\n            // Draw all stored frames\n            for (const frame of staticPixels) {\n                drawStaticFrame(frame);\n            }\n        }\n    }\n\n    // Generate a full frame of static dots\n    function generateStaticFrame(): StaticFrame {\n        // Calculate number of static dots with slight ratio applied for large screens\n        const screenRatio: number = Math.min(1.0, (canvas!.width * canvas!.height) / (1920 * 1080));\n        const dotsPerFrame: number = Math.floor((canvas!.width * canvas!.height) / config.staticDivisor * (config.density / config.maxStoredFrames) * screenRatio);\n\n        // Group dots by intensity for efficient drawing\n        const frameData: StaticFrame = {};\n\n        for (let i = 0; i < dotsPerFrame; i++) {\n            const x: number = Math.floor(Math.random() * canvas!.width);\n            const y: number = Math.floor(Math.random() * canvas!.height);\n\n            // Use integer intensity values\n            let intensity: number;\n            if (isDarkMode) {\n                intensity = Math.floor(config.darkIntensityMin + Math.random() * (config.darkIntensityMax - config.darkIntensityMin));\n            } else {\n                intensity = Math.floor(config.lightIntensityMin + Math.random() * (config.lightIntensityMax - config.lightIntensityMin));\n            }\n\n            const alpha: number = config.baseAlpha + (Math.random() - 0.5) * config.alphaVariance;\n\n            // Ensure we have an entry for this intensity\n            if (!frameData[intensity]) {\n                frameData[intensity] = {\n                    alpha: alpha,\n                    pixels: []\n                };\n            }\n\n            frameData[intensity].pixels.push([x, y]);\n        }\n\n        return frameData;\n    }\n\n    // Generate a partial frame for incremental updates\n    function generatePartialStaticFrame(): StaticFrame {\n        // Calculate number of static dots based on the partial redraw ratio\n        const screenRatio: number = Math.min(1.0, (canvas!.width * canvas!.height) / (1920 * 1080));\n        const dotsPerPartialFrame: number = Math.floor(\n            (canvas!.width * canvas!.height) / config.staticDivisor *\n            (config.density / config.maxStoredFrames) *\n            config.partialRedrawRatio *\n            screenRatio\n        );\n\n        // Group dots by intensity for efficient drawing\n        const frameData: StaticFrame = {};\n\n        for (let i = 0; i < dotsPerPartialFrame; i++) {\n            const x: number = Math.floor(Math.random() * canvas!.width);\n            const y: number = Math.floor(Math.random() * canvas!.height);\n\n            // Use integer intensity values\n            let intensity: number;\n            if (isDarkMode) {\n                intensity = Math.floor(config.darkIntensityMin + Math.random() * (config.darkIntensityMax - config.darkIntensityMin));\n            } else {\n                intensity = Math.floor(config.lightIntensityMin + Math.random() * (config.lightIntensityMax - config.lightIntensityMin));\n            }\n\n            const alpha: number = config.baseAlpha + (Math.random() - 0.5) * config.alphaVariance;\n\n            // Ensure we have an entry for this intensity\n            if (!frameData[intensity]) {\n                frameData[intensity] = {\n                    alpha: alpha,\n                    pixels: []\n                };\n            }\n\n            frameData[intensity].pixels.push([x, y]);\n        }\n\n        return frameData;\n    }\n\n    // Draw a frame of static dots\n    function drawStaticFrame(frameData: StaticFrame): void {\n        // Draw each intensity group in a batch\n        for (const intensity in frameData) {\n            const group: FramePixelGroup = frameData[intensity];\n            ctx!.fillStyle = `rgba(${intensity}, ${intensity}, ${intensity}, ${group.alpha})`;\n\n            for (const [x, y] of group.pixels) {\n                ctx!.fillRect(x, y, config.pixelSize, config.pixelSize);\n            }\n        }\n    }\n\n    // Draw the effect layer (special effects, sparkles, etc.)\n    function drawEffectLayer(): void {\n        // Optimize effect layer drawing\n        const screenRatio: number = Math.min(1.0, (canvas!.width * canvas!.height) / (1920 * 1080));\n\n        // Draw fewer effect dots by using this multiplier\n        const densityMultiplier: number = isDarkMode ? 60 : 50; // Higher values = fewer dots\n        const maxEffectDots: number = Math.floor(\n            (canvas!.width * canvas!.height) / densityMultiplier *\n            (config.intenseDensity - config.density) *\n            config.transitionProgress *\n            screenRatio\n        );\n\n        // Limit maximum dots for very large screens\n        const effectDots: number = Math.min(maxEffectDots, 7000); // Increased from 5000 to match higher density\n\n        // Batch similar colors together to reduce state changes\n        const effectColors: EffectColors = {\n            purple: [],  // Main effect color\n            cyan: [],    // Accent color\n            white: []    // Sparkles\n        };\n\n        // Calculate dots and store positions by color\n        for (let i = 0; i < effectDots; i++) {\n            const x: number = Math.floor(Math.random() * canvas!.width);\n            const y: number = Math.floor(Math.random() * canvas!.height);\n\n            // Add some colorful variation\n            const colorRoll: number = Math.random();\n\n            // Determine dot type based on probability (keep original feel)\n            if (colorRoll > (isDarkMode ? 0.93 : 0.9)) {\n                effectColors.white.push([x, y]);\n            } else if (colorRoll > (isDarkMode ? 0.9 : 0.85)) {\n                effectColors.cyan.push([x, y]);\n            } else {\n                effectColors.purple.push([x, y]);\n            }\n        }\n\n        // Draw main purple dots\n        if (effectColors.purple.length > 0) {\n            const colorIntensity: number = isDarkMode ? 0.85 : 1.0;\n            const r: number = Math.floor(config.intenseColor[0] * colorIntensity);\n            const g: number = Math.floor(config.intenseColor[1] * colorIntensity);\n            const b: number = Math.floor(config.intenseColor[2] * colorIntensity);\n            const baseAlpha: number = isDarkMode ? 0.75 : 0.9;\n            const alpha: number = baseAlpha * config.transitionProgress;\n\n            ctx!.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;\n\n            for (const [x, y] of effectColors.purple) {\n                // Keep 5% chance of larger dots for visual interest\n                const dotSize: number = Math.random() > 0.95 ? 2 : 1;\n                ctx!.fillRect(x, y, dotSize, dotSize);\n            }\n        }\n\n        // Draw cyan accent dots\n        if (effectColors.cyan.length > 0) {\n            const alpha: number = ((isDarkMode ? 0.6 : 0.8)) * config.transitionProgress;\n            ctx!.fillStyle = `rgba(150, 230, 255, ${alpha})`;\n\n            for (const [x, y] of effectColors.cyan) {\n                ctx!.fillRect(x, y, config.pixelSize, config.pixelSize);\n            }\n        }\n\n        // Draw white sparkles\n        if (effectColors.white.length > 0) {\n            const alpha: number = (isDarkMode ? 0.6 : 0.8) * config.transitionProgress;\n            ctx!.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n\n            for (const [x, y] of effectColors.white) {\n                // Keep white sparkles as 2px for visual pop\n                ctx!.fillRect(x, y, 2, 2);\n            }\n        }\n    }\n\n    // Helper function to update the effect state and transition progress\n    function updateEffectState(): void {\n        // Handle state transitions\n        switch(config.effectState) {\n            case 'intensifying':\n                // Increase the transition progress\n                config.transitionProgress += config.transitionSpeed;\n\n                // If we've reached the maximum intensity\n                if (config.transitionProgress >= 1) {\n                    config.transitionProgress = 1;\n                    config.effectState = 'intense'; // Switch to intense state\n                }\n                break;\n\n            case 'fading':\n                // Decrease the transition progress\n                config.transitionProgress -= config.transitionSpeed;\n\n                // If we've reached the normal state\n                if (config.transitionProgress <= 0) {\n                    config.transitionProgress = 0;\n                    config.effectState = 'normal'; // Switch to normal state\n                }\n                break;\n        }\n\n        // Update the current parameters based on transition progress\n        updateCurrentParameters();\n    }\n\n    // Helper function to update current parameters based on transition progress\n    function updateCurrentParameters(): void {\n        // Interpolate between normal and intense parameters with easing\n        // Use a quadratic easing function for smoother transitions at beginning and end\n        const easeInOut: number = config.transitionProgress < 0.5 ?\n            2 * config.transitionProgress * config.transitionProgress :\n            1 - Math.pow(-2 * config.transitionProgress + 2, 2) / 2;\n\n        // Set minimum density to never go below 90% of normal density\n        const minDensity: number = config.density * 0.9;\n\n        // Calculate current density with easing and minimum\n        config.currentDensity = Math.max(\n            minDensity,\n            config.density + (config.intenseDensity - config.density) * easeInOut\n        );\n\n        // Color mix can use the same easing for smooth transitions\n        config.currentColorMix = easeInOut;\n    }\n\n    // Function to update the mode based on the media query\n    function updateMode(event: MediaQueryListEvent): void {\n        isDarkMode = event.matches;\n\n        // Reset static pixels cache for new theme\n        staticPixels = [];\n    }\n\n    // Function to trigger the intensifying effect (keep as-is for gemini-mascot.js)\n    function enableMagicMode(): void {\n        // Keep the background in the normal state\n        config.effectState = 'normal';\n        config.transitionProgress = 0;\n    }\n\n    // Function to trigger the fading effect (keep as-is for gemini-mascot.js)\n    function disableMagicMode(): void {\n        // Always ensure the background returns to/stays in the normal state\n        config.effectState = 'normal';\n        config.transitionProgress = 0;\n    }\n\n    // Initial Setup\n    resizeCanvas(); // Set initial size\n\n    // Event Listeners\n    window.addEventListener('resize', resizeCanvas);\n\n    // Initialize system to normal state\n    config.effectState = 'normal';\n    config.transitionProgress = 0;\n\n    // Initialize current parameters (density, etc.)\n    updateCurrentParameters();\n\n    // Use performance data to adapt settings\n    // This function is initially empty but will gather data as the animation runs\n    // Note: Currently unused but kept for future performance monitoring\n    // @ts-ignore - Unused but kept for future performance monitoring\n    const performanceData: PerformanceData = {\n        frameTimes: [],\n        maxFrameTimes: 20, // Keep track of the last 20 frames\n        slowFrameThreshold: 50, // ms, consider a frame \"slow\" if it takes more than this\n        slowFrameCount: 0,\n        adaptationThreshold: 5, // adapt after this many slow frames\n\n        // Add a frame timing\n        addFrameTime: function(duration: number): void {\n            this.frameTimes.push(duration);\n            if (this.frameTimes.length > this.maxFrameTimes) {\n                this.frameTimes.shift(); // Remove oldest\n            }\n\n            // Check if this was a slow frame\n            if (duration > this.slowFrameThreshold) {\n                this.slowFrameCount++;\n\n                // If we've had too many slow frames, adapt\n                if (this.slowFrameCount >= this.adaptationThreshold) {\n                    this.adaptSettings();\n                    this.slowFrameCount = 0; // Reset counter\n                }\n            }\n        },\n\n        // Adapt settings based on performance\n        adaptSettings: function(): void {\n            // Calculate average frame time\n            const avgFrameTime: number = this.frameTimes.reduce((sum: number, time: number) => sum + time, 0) / this.frameTimes.length;\n\n            // If average frame time is too high, reduce density\n            if (avgFrameTime > this.slowFrameThreshold) {\n                // Only adapt if density is still high\n                if (config.density > 0.6) {\n                    config.density *= 0.9; // Reduce by 10%\n                    config.staticDivisor *= 1.1; // Increase divisor by 10%\n                }\n            }\n        }\n    };\n\n    // Start the animation\n    lastFrameTime = performance.now();\n    animationFrameId = requestAnimationFrame(drawStatic);\n\n    // Expose functions to window for other scripts to use\n    window.staticBackground = {\n        enableMagicMode,    // Transition to intense state\n        disableMagicMode,   // Transition back to normal state\n\n        // Add some utility functions for direct state control if needed\n        setIntense: function(): void {\n            config.effectState = 'intense';\n            config.transitionProgress = 1;\n            updateCurrentParameters();\n        },\n        setNormal: function(): void {\n            config.effectState = 'normal';\n            config.transitionProgress = 0;\n            updateCurrentParameters();\n        }\n    };\n\n    // Listen for system theme changes\n    const darkModeMediaQuery: MediaQueryList = window.matchMedia('(prefers-color-scheme: dark)');\n    darkModeMediaQuery.addEventListener('change', updateMode);\n     // Initialize isDarkMode based on current state\n    isDarkMode = darkModeMediaQuery.matches;\n\n    // Optional: Stop animation when tab is not visible (performance)\n    document.addEventListener('visibilitychange', (): void => {\n        if (document.hidden) {\n            cancelAnimationFrame(animationFrameId);\n        } else {\n            // Restart the animation loop\n            lastFrameTime = performance.now();\n            animationFrameId = requestAnimationFrame(drawStatic);\n        }\n    });\n\n    // Note: Magic mode is now explicitly controlled by gemini-mascot.js\n    // so we've removed the automatic observer to avoid conflicts\n\n}); // End DOMContentLoaded\n"],
  "mappings": "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",
  "names": []
}
